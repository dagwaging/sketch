<link rel="import" href="../../bower_components/polymer/polymer.html">
<link rel="import" href="../../bower_components/paper-styles/shadow.html">
<link rel="import" href="../../bower_components/iron-resizable-behavior/iron-resizable-behavior.html">
<link rel="import" href="../sketch-data/sketch-data.html">

<dom-module id="sketch-canvas">
  <template>
    <style>
      :host {
        @apply(--shadow-elevation-4dp);
        display: block;
        cursor: crosshair;
      }

      #sketchCanvas {
        width: 100%;
        height: 100%;
        background: white;
      }
    </style>
    <canvas
        id="sketchCanvas"
        on-track="_onTrack"
        on-tap="_onTrack"
        width="800"
        height="600"></canvas>
    <sketch-data
        id="data"
        length="{{dataLength}}"
        can-undo="{{dataCanUndo}}"
        can-redo="{{dataCanRedo}}"></sketch-data>
  </template>
  <script>
  (function() {
    Polymer({
      is: 'sketch-canvas',

      ready: function() {
        Polymer.Gestures.gestures.track.hasMovedEnough = function() { return true; };
        this._canvas = this.$.sketchCanvas.getContext("2d");
        this._canvas.strokeStyle = "black";
        this._canvas.lineWidth = 3;
        this._canvas.lineJoin = "round";
        this._canvas.lineCap = "round";
        this._canvas.fillStyle = "black";
      },

      behaviors: [
        Polymer.IronResizableBehavior
      ],

      listeners: {
        'iron-resize': '_onIronResize'
      },

      // Public properties

      properties: {
        ink: {
          type: Number,
          notify: true,
          readOnly: true,
          computed: 'computeInk(dataLength)'
        },
        playing: {
          type: Boolean,
          readOnly: true,
          value: false
        },
        erasing: {
          type: Boolean,
          notify: true,
          value: false
        },
        disabled: {
          type: Boolean,
          notify: true,
          value: false
        },
        canUndo: {
          type: Boolean,
          notify: true,
          computed: '_canEdit(dataCanUndo, disabled)'
        },
        canRedo: {
          type: Boolean,
          notify: true,
          computed: '_canEdit(dataCanRedo, disabled)'
        }
      },

      get data() {
        return this.$.data.data;
      },

      set data(data) {
        this.$.data.data = data;
        this._render();
      },

      get canvasData() {
        return this.$.sketchCanvas.toDataURL("image/png");
      },

      // Private properties

      _canvas: null,

      _playProgressLines: 0,

      _playProgressPoints: 0,

      _lastTimestamp: null,

      _bounds: null,

      // Public methods

      play: function() {
        this._clear();
        this._setPlaying(true);
        this._playProgressLines = 0;
        this._playProgressPoints = 0;
        this._lastTimestamp = null;
        window.requestAnimationFrame(this._animate.bind(this));
      },

      stop: function() {
        this._setPlaying(false);
      },

      undo: function(event) {
        if(!this.disabled) {
          this.$.data.undo();
          this._render();
        }
      },

      redo: function(event) {
        if(!this.disabled) {
          this.$.data.redo();
          this._render();
        }
      },

      computeInk: function(dataLength) {
        return dataLength / this.$.data.MAX_LENGTH;
      },

      // Private methods

      _onIronResize: function(event) {
        this._bounds = this.getBoundingClientRect();
      },

      _onTrack: function(event) {
        event.preventDefault();

        if(!this.disabled) {
          event = this._fixInput(event);

          if(event == null) {
            return;
          }

          var point = this._scaleCoordinates(this._bounds, event.detail.x, event.detail.y, 800, 600);
          var x = point[0];
          var y = point[1];

          if(this.erasing) {
            var previousPoint = this._scaleCoordinates(this._bounds, event.detail.x - event.detail.ddx || 0, event.detail.y - event.detail.ddy || 0, 800, 600);
            var px = previousPoint[0];
            var py = previousPoint[1];
            this._erase(x, y, px, py);
          }
          else {
            if(event.type == 'track') {
              switch(event.detail.state) {
                case 'start':
                  this._startLine(x, y);
                  break;
                case 'track':
                  this._addPoint(x, y);
                  break;
                case 'end':
                  this._endLine(x, y);
                  break;
              }
            }
            else if(event.type == 'tap') {
              this._startLine(x, y);
              this._endLine(x, y);
            }
          }
        }
      },

      _fixInput: function(event) {
        if(event.type == 'track') {
          var x = event.detail.x;
          var y = event.detail.y;

          var dx = event.detail.ddx;
          var dy = event.detail.ddy;

          var px = x - dx;
          var py = y - dy;

          var isInBounds = this._contains(this._bounds, x, y);
          var wasInBounds = this._contains(this._bounds, px, py);

          if(isInBounds) {
            if(!wasInBounds) {
              event.detail.state = "start";
              // TODO: insert additional 'start' event on border
            }
          }
          else {
            if(wasInBounds) {
              event.detail.state = "end";
              event.detail.x = px;
              event.detail.y = py;
              // TODO: move event to border
            }
            else {
              event = null;
            }
          }
        }

        return event;
      },

      _contains: function(bounds, x, y) {
        return x >= bounds.left && x <= bounds.right && y >= bounds.top && y <= bounds.bottom;
      },

      _scaleCoordinates: function(bounds, x, y, width, height) {
          x = Math.round(width * (x - bounds.left) / bounds.width);
          y = Math.round(height * (y - bounds.top) / bounds.height);
          return [x, y];
      },

      _startLine(x, y) {
        this.$.data.addLine([x, y]);
      },

      _addPoint(x, y) {
        this.$.data.addPoint(x, y);
        var lastLine = this.$.data.lines[this.$.data.lines.length - 1];
        this._drawLine(lastLine.slice(lastLine.length - 4, lastLine.length));
      },

      _endLine(x, y) {
        this.$.data.endLine(x, y);
        var lastLine = this.$.data.lines[this.$.data.lines.length - 1];
        this._drawLine(lastLine.slice(lastLine.length - 4, lastLine.length));
      },

      _erase(x, y, px, py) {
        this.$.data.erase(x, y, px, py, 3);
      },

      _drawLine(points) {
        if(points[0] == points[2] && points[1] == points[3]) {
          this._canvas.beginPath();
          this._canvas.arc(points[0], points[1], 1.5, 0, Math.PI * 2);
          this._canvas.fill();
        }

        this._canvas.beginPath();
        this._canvas.moveTo(points[0], points[1]);
        for(var i = 2; i < points.length; i += 2) {
            this._canvas.lineTo(points[i], points[i + 1]);
        }
        this._canvas.stroke();
      },

      _clear() {
        this._canvas.fillStyle = "white";
        this._canvas.fillRect(0, 0, 800, 600);
        this._canvas.fillStyle = "black";
      },

      _animate(timestamp) {
        if(this._lastTimestamp) {
          var timeDelta = timestamp - this._lastTimestamp;
          var pointsToDraw = timeDelta / 1000 * 100;
          var pointsDrawn = 0;

          while(pointsDrawn < pointsToDraw && this.playing) {
            this._drawLine(this.$.data.lines[this._playProgressLines].slice(this._playProgressPoints, this._playProgressPoints + 4));

            pointsDrawn++;
            this._playProgressPoints += 2;
            if(this._playProgressPoints >= this.$.data.lines[this._playProgressLines].length - 2) {
              this._playProgressPoints = 0;
              this._playProgressLines++;
              if(this._playProgressLines >= this.$.data.lines.length) {
                break;
              }
            }
          }
        }

        this._lastTimestamp = timestamp;

        if(this.playing && this._playProgressLines < this.$.data.lines.length) {
          window.requestAnimationFrame(this._animate.bind(this));
        }
      },

      _render() {
        this._clear();

        for(var i in this.$.data.lines) {
          this._drawLine(this.$.data.lines[i]);
        }
      },

      _canEdit(canEdit, disabled) {
        return canEdit && !disabled;
      }
    });
  })();
  </script>
</dom-module>
