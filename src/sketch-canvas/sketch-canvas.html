<link rel="import" href="../../bower_components/polymer/polymer.html">
<link rel="import" href="../../bower_components/paper-styles/shadow.html">

<dom-module id="sketch-canvas">
  <template>
    <style>
      :host {
        @apply(--shadow-elevation-4dp);
        display: block;
        cursor: crosshair;
      }

      #sketchCanvas {
        width: 100%;
        height: 100%;
      }
    </style>
    <canvas id="sketchCanvas" on-track="_onTrack" on-tap="_onTrack" width="800" height="600"></canvas>
  </template>
  <script>
  (function() {
    var MAX_DATA_LENGTH = 65535;

    Polymer({
      is: 'sketch-canvas',

      ready: function() {
        this._canvas = this.$.sketchCanvas.getContext("2d");
        this._canvas.strokeStyle = "black";
        this._canvas.lineWidth = 3;
        this._canvas.lineJoin = "round";
        this._canvas.lineCap = "round";
        this._canvas.fillStyle = "black";
      },

      // Public properties

      properties: {
        ink: {
          type: Number,
          notify: true,
          readOnly: true,
          computed: 'computeInk(dataLength)'
        },
        dataLength: {
          type: Number,
          value: 0,
          notify: true,
          readOnly: true
        },
        playing: {
          type: Boolean,
          readOnly: true,
          value: false
        },
        disabled: {
          type: Boolean,
          value: false
        },
        canUndo: {
          type: Boolean,
          notify: true,
          readOnly: true,
          value: false
        },
        canRedo: {
          type: Boolean,
          notify: true,
          readOnly: true,
          value: false
        }
      },

      get data() {
        var data = [];

        for(var i in this._lines) {
          var line = new Array(this._lines[i].length);

          for(var j in this._lines[i]) {
            line[j] = this._pad(this._lines[i][j].toString(36), 2);
          }

          data.push(line.join(""));
        }

        return data.join(" ");
      },

      set data(data) {
        var lines = data.length > 0 ? data.split(" ") : [];
        this._lines = new Array(lines.length);
        this._length = this._lines.length;
        this._setDataLength(data.length);
        this._setCanUndo(this._length > 0);
        this._setCanRedo(false);

        for(var i in lines) {
          var line = new Array(lines[i].length / 2);

          for(var j = 0; j < lines[i].length; j += 2) {
            line[j / 2] = parseInt(lines[i].substr(j, 2), 36);
          }

          this._lines[i] = line;
        }

        this._render();
      },

      get canvasData() {
        return this.$.sketchCanvas.toDataURL("image/png");
      },

      // Private properties

      _canvas: null,

      _lines: [],

      _length: 0,

      _playProgressLines: 0,

      _playProgressPoints: 0,

      _lastTimestamp: null,

      // Public methods

      play: function() {
        this._clear();
        this._setPlaying(true);
        this._playProgressLines = 0;
        this._playProgressPoints = 0;
        this._lastTimestamp = null;
        window.requestAnimationFrame(this._animate.bind(this));
      },

      stop: function() {
        this._setPlaying(false);
      },

      undo: function() {
        if(!this.canUndo || this.disabled) {
          return;
        }

        this._length--;
        this._setDataLength(this.dataLength - this._lines[this._length].length * 2 - 1);
        this._render();

        this._setCanUndo(this._length > 0);
        this._setCanRedo(this._lines.length > 0);
      },

      redo: function() {
        if(!this.canRedo || this.disabled) {
          return;
        }

        this._setDataLength(this.dataLength + this._lines[this._length].length * 2 + 1);
        this._length++;
        this._render();

        this._setCanUndo(this._lines.length > 0);
        this._setCanRedo(this._length < this._lines.length);
      },

      computeInk: function(dataLength) {
        return Math.floor(dataLength * 100 / MAX_DATA_LENGTH);
      },

      // Private methods

      _onTrack: function(event) {
        if(this.disabled || this.dataLength >= MAX_DATA_LENGTH) {
          return;
        }

        var x = Math.round(800.0 * event.detail.sourceEvent.offsetX / event.srcElement.offsetWidth);
        var y = Math.round(600.0 * event.detail.sourceEvent.offsetY / event.srcElement.offsetHeight);

        if(event.type == 'track') {
          switch(event.detail.state) {
            case 'start':
              this._setCanUndo(true);
              this._setCanRedo(false);
              this._startLine(x, y);
              break;
            case 'track':
            case 'end':
              this._addPoint(x, y);
              break;
          }
        }
        else if(event.type == 'tap') {
          this._setCanUndo(true);
          this._setCanRedo(false);
          this._startLine(x, y);
          this._addPoint(x, y);
        }
      },

      _startLine(x, y) {
        this._lines.length = this._length;
        this._lines.push([x, y]);
        this._setDataLength(this.dataLength + 5);
        this._length++;
      },

      _addPoint(x, y) {
        var lastLine = this._lines[this._lines.length - 1];
        lastLine.push(x, y);
        this._setDataLength(this.dataLength + 4);
        this._drawLine(lastLine.slice(lastLine.length - 4, lastLine.length));
      },

      _drawLine(points) {
        if(points[0] == points[2] && points[1] == points[3]) {
          this._canvas.beginPath();
          this._canvas.ellipse(points[0], points[1], 1.5, 1.5, 0, 0, Math.PI * 2);
          this._canvas.fill();
        }

        this._canvas.beginPath();
        this._canvas.moveTo(points[0], points[1]);
        for(var i = 2; i < points.length; i += 2) {
            this._canvas.lineTo(points[i], points[i + 1]);
        }
        this._canvas.stroke();
      },

      _clear() {
        this._canvas.fillStyle = "white";
        this._canvas.fillRect(0, 0, 800, 600);
        this._canvas.fillStyle = "black";
      },

      _animate(timestamp) {
        if(this._lastTimestamp) {
          var timeDelta = timestamp - this._lastTimestamp;
          var pointsToDraw = timeDelta / 1000 * 100;
          var pointsDrawn = 0;

          while(pointsDrawn < pointsToDraw && this.playing) {
            this._drawLine(this._lines[this._playProgressLines].slice(this._playProgressPoints, this._playProgressPoints + 4));

            pointsDrawn++;
            this._playProgressPoints += 2;
            if(this._playProgressPoints >= this._lines[this._playProgressLines].length - 2) {
              this._playProgressPoints = 0;
              this._playProgressLines++;
              if(this._playProgressLines >= this._lines.length) {
                break;
              }
            }
          }
        }

        this._lastTimestamp = timestamp;

        if(this.playing && this._playProgressLines < this._lines.length) {
          window.requestAnimationFrame(this._animate.bind(this));
        }
      },

      _render() {
        this._clear();

        for(var i = 0; i < this._length; i++) {
          this._drawLine(this._lines[i]);
        }
      },

      _pad: function(n, width) {
        return Math.pow(10, Math.max(0, width - n.length)).toString().substr(1) + n;
      }
    });
  })();
  </script>
</dom-module>
